{
    "collab_server" : "",
    "contents" : "#' Class to store \\code{gantt} objects\nsetClass(\"gantt\", contains=\"plan\")\n\n\n#' Draw a Gantt diagram\n#' \n#' Plot a gantt chart, possibly with events superimposed.\n#' \n#' @param x A \\code{gantt} object, i.e. one inheriting from \\code{\\link{gantt-class}}.\n#' @param xlim optional range of time axis; if not provided, the range of times\n#' in \\code{x} will be used.\n#' @param time.format format for dates on time axis; defaults to 3-letter\n#' month.\n#' @param time.labels.by suggested label increment on time axis, e.g.\n#' \\code{time.labels.by=\"2 months\"} to get a two-month interval.  If not\n#' supplied, the axis will be generated automatically.\n#' @param time.lines.by suggested interval between vertical grid lines on the\n#' plot, e.g. \\code{time.lines.by=\"1 week\"} for weekly.  If not supplied, the\n#' grid will be generated automatically.\n#' @param event.time vector of event times, e.g. conferences, whose time cannot\n#' be altered.\n#' @param event.label vector of character strings holding event names.\n#' @param event.side side for event labels.\n#' @param col.connector colour of (optional) connectors between items.\n#' @param col.done colour of work that has been done already. This may be a\n#' vector of colours, one for each item in the gantt table.\n#' @param col.notdone colour of work that has not been done yet. This may be a\n#' vector of colours, one for each item in the gantt table.\n#' @param col.eventLine colour of event lines; may be a vector.\n#' @param col.event colour of event labels; may be a vector.\n#' @param cex.event expansion factor for event labels; may be a vector.\n#' @param lty.eventLine line type for event lines; may be a vector.\n#' @param lwd.eventLine line width for event lines; may be a vector.\n#' @param font.event font for event labels; may be a vector.\n#' @param bg background colour for plot.\n#' @param grid.col colour for grid.\n#' @param grid.lty line type for grid.\n#' @param ylabels A \\code{\\link{list}} with elements \\code{col} for colour,\n#' \\code{cex} for character-expansion factor, \\code{font} for font, and \\code{justification}\n#' for the placement in the margin (\\code{0} means left-justified, and \\code{1}\n#' means right-justified. In each case, the first entry applies to the top task on the graph,\n#' the second for second-top, etc.  If there are not enough values to match the labels,\n#' the vectors are filled out with the default values, e.g. \n#' \\code{ylabels=list(col=c(\"red\",\"blue\"))} sets red for the top-most label,\n#' blue for the one below, and black for any others; see Example 6.\n#' @param main character string to be used as chart title.\n#' @param cex.main numeric, font-size factor for title.\n#' @param mgp setting for \\code{\\link{par}(mgp)}, within-axis spacing.\n#' @param maiAdd inches to add to the auto-computed margins at the bottom,\n#' left, top, and right margins. The values may be negative (to tighten\n#' margins) but the sum will be truncated to remain positive.\n#' @param debug boolean, set to \\code{TRUE} to monitor the work.\n#' @param ... extra things handed down.\n#' @return The gantt object, returned invisibly.\n#' @note The defaults work well for projects that take a year or two. Consider\n#' adjusting \\code{time.labels.by} and \\code{time.lines.by} for projects that\n#' are much shorter or longer.\n#' @author Dan Kelley\n#' @family things related to \\code{gantt} data\n#' @references Gantt diagrams are described on wikipedia\n#' \\url{http://en.wikipedia.org/wiki/Gantt_Chart}.\n#' @section Sample data file:\n#' \\preformatted{\n#' Key, Description,                 Start,        End, Done, NeededBy\n#'   1, Assemble equipment,     2008-01-01, 2008-03-28, 90\n#'   2, Test methods,           2008-02-28, 2008-03-28, 30\n#'   3, Field sampling,         2008-04-01, 2008-08-14, 0\n#'   4, Analyse field data,     2008-06-30, 2008-11-14, 0\n#'   5, Write methods chapter,  2008-08-14, 2008-11-14, 0\n#'   6, Write results chapter,  2008-10-14, 2009-01-15, 0\n#'   7, Write other chapters,   2008-12-10, 2009-02-28, 0\n#'   8, Committee reads thesis, 2009-02-28, 2009-03-14, 0\n#'   9, Revise thesis,          2009-03-15, 2009-03-30, 0\n#'  10, Thesis on display,      2009-04-01, 2009-04-15, 0\n#'  11, Defend thesis,          2009-04-16, 2009-04-17, 0\n#'  12, Finalize thesis,        2009-04-18, 2009-05-07, 0 \n#' }\n#' @examples\n#' \n#' library(plan)\n#' data(gantt)\n#' summary(gantt)\n#' # 1. Simple plot\n#' plot(gantt)\n#' # 2. Plot with two events\n#' event.label <- c(\"Proposal\", \"AGU\")\n#' event.time <- c(\"2008-01-28\", \"2008-12-10\")\n#' plot(gantt, event.label=event.label,event.time=event.time)\n#' # 3. Control x axis (months, say)\n#' plot(gantt,labels=paste(\"M\",1:6,sep=\"\"))\n#' # 4. Control task colours\n#' plot(gantt,\n#'      col.done=c(\"black\", \"red\", rep(\"black\", 10)),\n#'      col.notdone=c(\"lightgray\", \"pink\", rep(\"lightgray\", 10)))\n#' # 5. Control event colours (garish, to illustrate)\n#' plot(gantt, event.time=event.time, event.label=event.label,\n#'      lwd.eventLine=1:2, lty.eventLine=1:2,\n#'      col.eventLine=c(\"pink\", \"lightblue\"),\n#'      col.event=c(\"red\", \"blue\"), font.event=1:2, cex.event=1:2)\n#' # 6. Colour-coded tasks\n#' plot(gantt,ylabels=list(col=c(\"red\",\"blue\"),font=c(rep(1,11),2)))\nsetMethod(f=\"plot\",\n          signature=signature(\"gantt\"),\n          definition=function (x, xlim,\n                        time.format=NULL, time.labels.by, time.lines.by,\n                        event.time=NULL, event.label=NULL, event.side=3,\n                        col.connector=\"black\",\n                        col.done=gray(0.3), col.notdone=gray(0.9),\n                        col.eventLine=gray(0.1), col.event=par(\"fg\"), \n                        cex.event=par(\"cex\"), font.event=par(\"font\"),\n                        lty.eventLine=par(\"lty\"), lwd.eventLine=par(\"lwd\"),\n                        bg=par(\"bg\"), grid.col=\"lightgray\", grid.lty=\"dotted\",\n                        ylabels=list(col=1, cex=1, font=1, justification=1),\n                        main=\"\", cex.main=par(\"cex\"),\n                        mgp=c(2, 0.7, 0), maiAdd=rep(0, 4),\n                        debug=FALSE, ...)\n{\n    if (!inherits(x, \"gantt\")) stop(\"method is only for gantt objects\")\n    opar <- par(no.readonly = TRUE)\n\n    mgp <- c(3, 1, 0)\n    half.height <- 0.33\n    t0 <- as.POSIXct(\"1970-01-01 00:00:00\")\n    ## Lengthen anything that can be a vector\n    ndescriptions <- length(x[[\"description\"]])\n    ## Twiddle the labels, including defaulting things that a user\n    ## need not define.\n    if (!(\"col\" %in% names(ylabels)))\n        ylabels$col <- 1\n    if (!(\"cex\" %in% names(ylabels)))\n        ylabels$cex <- 1\n    if (!(\"font\" %in% names(ylabels)))\n        ylabels$font <- 1\n    if (!(\"justification\" %in% names(ylabels)))\n        ylabels$justification <- 1\n    for (i in seq_along(ylabels)) {\n        len <- length(ylabels[[i]])\n        if (len < ndescriptions) {\n            ylabels[[i]] <- c(ylabels[[i]], rep(1, ndescriptions-len))\n        }\n    }\n    if (any(ylabels$justification != 0 && ylabels$justification != 1))\n        stop(\"ylabels$justification entries must be 0 or 1\")\n    if (length(col.done) < ndescriptions)\n        col.done <- rep(col.done, length.out=ndescriptions)\n    if (length(col.notdone) < ndescriptions)\n        col.notdone <- rep(col.notdone, length.out=ndescriptions)\n    nevent <- length(event.time)\n    if (length(col.eventLine) < nevent)\n        col.eventLine <- rep(col.eventLine, length.out=nevent)\n    if (length(col.event) < nevent)\n        col.event <- rep(col.event, length.out=nevent)\n    if (length(cex.event) < nevent)\n        cex.event <- rep(cex.event, length.out=nevent)\n    if (length(font.event) < nevent)\n        font.event <- rep(font.event, length.out=nevent)\n    if (length(lty.eventLine) < nevent)\n        lty.eventLine <- rep(lty.eventLine, length.out=nevent)\n    if (length(lwd.eventLine) < nevent)\n        lwd.eventLine <- rep(lwd.eventLine, length.out=nevent)\n\n    charheight <- strheight(\"M\", units = \"inches\")\n    maxwidth <- max(strwidth(x[[\"description\"]], units = \"inches\")) * 1.1\n\n    ## Get around some problems with autoscaling of POSIXt values\n    r <- if (missing(xlim)) range(x[[\"start\"]], x[[\"end\"]]) else xlim\n    if (debug) {cat(\"range: \", as.character(r[1]), \"to\", as.character(r[2]), \"\\n\")}\n    s <- as.numeric(difftime(r[2], r[1], units=\"days\"))\n    r <- as.POSIXlt(r)\n    subTics <- NULL\n    if (s > 100) {\n        if (is.null(time.format)) time.format <-  \"%b %Y\" # month/year\n        r[2] <- r[2] + 86400\n        r[1:2]$hour <- r[1:2]$min <- r[1:2]$sec <- 0\n        if (debug){cat(\"range: \", as.character(r[1]), \"to\", as.character(r[2]), \"\\n\")}\n        ## monthly ticks\n        lhs <- as.POSIXlt(r[1])\n        lhs$mon <- 0\n        lhs$mday <- 1\n        rhs <- as.POSIXlt(r[2])\n        rhs$mon <- 11\n        rhs$mday <- 31\n        subTics <- seq(lhs, rhs, by=\"month\")\n    } else {\n        if (s > 10) {\n            if (is.null(time.format)) time.format <-  \"%d/%b\" # day/month\n            r[2] <- r[2] + 86400\n            r[1:2]$hour <- r[1:2]$min <- r[1:2]$sec <- 0\n            if(debug){cat(\"range: \", as.character(r[1]), \"to\", as.character(r[2]), \"\\n\")}\n        } else {\n            if (s > 1) {\n                if (is.null(time.format)) time.format <-  \"%d/%b\" # day/month\n                r[2] <- r[2] + 86400\n                r[1:2]$hour <- r[1:2]$min <- r[1:2]$sec <- 0\n                if(debug){cat(\"range: \", as.character(r[1]), \"to\", as.character(r[2]), \"\\n\")}\n            } else {\n                if (is.null(time.format)) time.format <-  \"%d/%b\" # day/month\n            }\n        }\n    }\n    bottom.margin <- 0.5\n    topSpace <- charheight * (2 + 2*as.numeric((nchar(main) > 0)))\n    mai <- maiAdd + c(bottom.margin, maxwidth, topSpace, 0.1)\n    mai <- ifelse(mai < 0, 0, mai)\n    opar <- par(no.readonly = TRUE)\n    par(mgp=mgp, mai=mai, omi=c(0.1, 0.1, 0.1, 0.1), bg=bg)\n    print(mai)\n    plot(c(r[1], r[2]), c(1,2*ndescriptions),\n         ylim=c(0.5, ndescriptions + 0.5),\n         xaxs=\"i\", yaxs=\"i\",\n         bg=bg,\n         main=\"\", xlab=\"\", ylab=\"\", xaxs=\"r\", type=\"n\", axes=FALSE)\n    xlim <- as.POSIXct(par(\"usr\")[1:2] + t0)\n    box()\n    if (nchar(main)) {\n        line <- if (nevent > 0) 2 else 1\n        mtext(main, side=3, line=line, cex=cex.main)\n    }\n    if (missing(time.labels.by)) {\n        xaxp <- par(\"xaxp\")\n        lines.at.0 <- axis.POSIXct(1,\n                                   at=pretty(r, 10), #seq(xaxp[1], xaxp[2], length.out=xaxp[3]) + t0,\n                                   format=time.format, cex.axis=par(\"cex.axis\"), ...)\n    } else {\n        lines.at.0 <- axis.POSIXct(1,\n                                   at=as.POSIXct(seq.POSIXt(as.POSIXct(xlim[1]), as.POSIXct(xlim[2]), by=time.labels.by)),\n                                   format=time.format, cex.axis=par(\"cex.axis\"), ...)\n    }\n    if (!is.null(subTics))\n        rug(subTics, quiet=TRUE)\n    if (missing(time.lines.by)) {\n        abline(v=lines.at.0, col = grid.col, lty=grid.lty)\n    } else {\n        abline(v = seq.POSIXt(as.POSIXct(xlim[1]), as.POSIXct(xlim[2]), by=time.lines.by), col = grid.col, lty=grid.lty)\n    }\n    topdown <- seq(ndescriptions, 1)\n    font <- rep(1, ndescriptions)\n    font[2] <- 2\n    dat <- axis(2, at=topdown, labels=rep(\"\", ndescriptions), las=2, tick=FALSE, cex.axis=par(\"cex.axis\"))\n    par(xpd=NA)\n    print(ylabels$justification)\n    for (i in 1:ndescriptions) {\n        if (ylabels$justification[i] == 1) {\n            left <- par('usr')[1]\n            text(left, topdown[i], x[[\"description\"]][i], pos=2,\n                 col=ylabels$col[i], cex=ylabels$cex[i], font=ylabels$font[i])\n        } else {\n            left <- grconvertX(0, 'device', 'user')\n            message(\"left= \", left)\n            text(left, topdown[i], x[[\"description\"]][i], pos=4,\n                 col=ylabels$col[i], cex=ylabels$cex[i], font=ylabels$font[i])\n            abline(v=left, lwd=5)\n        }\n    }\n    par(xpd=FALSE)\n\n    ## Connectors\n    for (t in 1:ndescriptions) {\n        nb <- x[[\"neededBy\"]][t][[1]]\n        if (!is.na(nb)) {\n            source.y <- topdown[t]\n            source.t <- as.POSIXct(x[[\"end\"]][t])\n            for (nbi in 1:length(nb)) {\n                r <- as.numeric(nb[nbi])\n                receiver.t <- as.POSIXct(x[[\"start\"]][r])\n                receiver.y <- topdown[r]\n                lines(c(source.t,receiver.t), c(source.y,receiver.y),col=col.connector)\n            }\n        }\n    }\n    ## Events\n    if (!is.null(event.time)) {\n        ne <- length(event.time)\n        for (e in 1:ne) {\n            t <- as.POSIXct(event.time[e])\n            abline(v=t, col=col.event[e], lwd=lwd.eventLine[e], lty=lty.eventLine[e])\n            mtext(event.label[e], side=event.side, at=t, \n                  col=col.event[e], font=font.event[e], cex=cex.event[e])\n        }\n    }\n    ## Description\n    for (i in 1:ndescriptions) {\n        mid <- as.POSIXct(x[[\"start\"]][i]) +\n            x[[\"done\"]][i] * as.numeric(difftime(as.POSIXct(x[[\"end\"]][i]),\n                                            as.POSIXct(x[[\"start\"]][i]),\n                                            units=\"secs\")) / 100\n        if (debug) {cat(as.character(x[[\"description\"]][i]),\"takes\", as.numeric(difftime(as.POSIXct(x[[\"end\"]][i]), as.POSIXct(x[[\"start\"]][i]), units=\"secs\")), \"s\\n\")}\n\n        bottom <- topdown[i] - half.height\n        top <- topdown[i] + half.height\n        left <- as.POSIXct(x[[\"start\"]][i])\n        right <- as.POSIXct(x[[\"end\"]][i])\n\n        if (debug){cat(as.character(x[[\"description\"]][i]));cat(\" done=\",x[[\"done\"]][i],\" mid=\");print(mid);cat(\" left=\");print(left);cat(\"right=\");print(right);cat(\"\\n\")}\n\n        rect(left, bottom, right, top, col = col.notdone[i], border = FALSE)\n        rect(left, bottom, mid,   top, col = col.done[i],    border = FALSE)\n        rect(left, bottom, right, top, col = \"transparent\",  border = TRUE)\n    }\n    abline(h = (topdown[1:(ndescriptions - 1)] + topdown[2:ndescriptions])/2,  col = grid.col, lty=grid.lty)\n    par(opar)\n    invisible(x)\n})\n\n\n\n\n\n#' Summarize a gantt object\n#' \n#' Summarizes a gantt object.\n#' \n#' Prints a summary of a gantt dataset.\n#' \n#' @param object A \\code{gantt} object, i.e. one inheriting from \\code{\\link{gantt-class}}.\n#' @param ... ignored.\n#' @author Dan Kelley\n#' @family things related to \\code{gantt} data\n#' @references\n#' \\url{http://alistair.cockburn.us/crystal/articles/evabc/earnedvalueandburncharts.htm}.\n#' @examples\n#' library(plan)\n#' data(gantt)\n#' summary(gantt)\nsetMethod(f=\"summary\",\n          signature=\"gantt\",\n          definition=function(object, ...) {\n              max.description.width <- max(nchar(as.character(object[[\"description\"]])))\n              num.descriptions <- length(object[[\"description\"]])\n              cat(\"Key, Description,\", paste(rep(\" \", max.description.width-12), collapse=\"\"), \"Start,      End,        Done, NeededBy\\n\")\n              for (t in 1:num.descriptions) {\n                  spacer <- paste(rep(\" \", 1 + max.description.width - nchar(as.character(object[[\"description\"]][t]))),\n                                  collapse=\"\")\n                  cat(paste(format(object[[\"key\"]][t], width=3, justify=\"right\"), \",\", sep=\"\"),\n                      paste(as.character(object[[\"description\"]][t]), \",\",\n                            spacer,\n                            format(object[[\"start\"]][t]), \", \",\n                            object[[\"end\"]][t],  \", \",\n                            format(object[[\"done\"]][t], width=4, justify=\"right\"), sep = \"\"))\n                  nb <- object[[\"neededBy\"]][t][[1]]\n                  if (!is.null(nb) && !is.na(nb[1])) {\n                      cat(\", \")\n                      for (nbi in 1:length(nb)) {\n                          cat(object[[\"description\"]][as.numeric(nb[nbi])], \" \")\n                      }\n                  }\n                  cat(\"\\n\")\n              }\n          })\n\n\n\n\n\n#' Create a \\code{gantt} object, i.e. one inheriting from \\code{\\link{gantt-class}}.\n#' \n#' @param key integer key for task, normally 1 for the first task, 2 for the\n#' second, etc.\n#' @param description character string describing the task (brief)\n#' @param start start date for task (POSIXt or character string that converts\n#' to POSIXt with \\code{\\link{as.POSIXct}}\n#' @param end end date for task (POSIXt or character string that converts to\n#' POSIXt with \\code{\\link{as.POSIXct}}\n#' @param done percentage completion for the task\n#' @param neededBy optional key for a dependent task\n#' @return An object of type \\code{\"gantt\"}; for details, see\n#' \\code{\\link{read.gantt}}.\n#' @author Dan Kelley\n#' @family things related to \\code{gantt} data\n#' @examples\n#' \n#' library(plan)\n#' arrive <- as.POSIXct(\"2012-09-05\")\n#' month <- 28 * 86400\n#' year <- 12 * month\n#' leave <- arrive + 4 * year\n#' startT1 <- arrive\n#' endT1 <- startT1 + 4 * month\n#' startT2 <- endT1 + 1\n#' endT2 <- startT2 + 4 * month\n#' startT3 <- arrive + 12 * month\n#' endT3 <- startT3 + 4 * month\n#' startQE <- arrive + 9 * month\n#' endQE <- arrive + 12 * month\n#' QEabsoluteEnd <- arrive + 15 * month\n#' startProposal <- arrive + 15 * month # for example\n#' endProposal <- arrive + 20 * month\n#' startThesisWork <- arrive + 2 * month # assumes no thesis work until 2 months in\n#' endThesisWork <- leave - 4 * month\n#' startThesisWriteup <- leave - 4 * month\n#' endThesisWriteup <- leave\n#' g <- as.gantt(key=1:7, c(\"Term 1 classes\",\n#'               \"Term 2 classes\",\n#'               \"Qualifying Examination\",\n#'               \"Term 3 classes\",\n#'               \"Proposal Defence\",\n#'               \"Thesis Work\",\n#'               \"Thesis Writing/Defence\"),\n#'               c(startT1, startT2, startQE, startT3, startProposal,\n#'                 startThesisWork, startThesisWriteup),\n#'               c(endT1, endT2, endQE, endT3, endProposal,\n#'                 endThesisWork, endThesisWriteup),\n#'               done=rep(0, 7))\n#' plot(g, xlim=c(arrive, leave))\n#' \nas.gantt <- function(key, description, start, end, done, neededBy)\n{\n    if (missing(key))\n        stop(\"must give 'key'\")\n    if (missing(description))\n        stop(\"must give 'description'\")\n    if (missing(start))\n        stop(\"must give 'start'\")\n    if (missing(end))\n        stop(\"must give 'end'\")\n    n <- length(key)\n    if (missing(done))\n        done <- rep(0, n)\n    if (missing(neededBy))\n        neededBy <- rep(NA, n)\n    rval <- new(\"gantt\")\n    rval@data <- list(key=key,\n                      description=as.character(description),\n                      start=as.POSIXct(start),\n                      end=as.POSIXct(end),\n                      done=done,\n                      neededBy=neededBy)\n    rval\n}\n\n\n\n\n\n#' Read a gantt data file\n#' \n#' Read a data file containing gantt information.\n#' The data format is strict, and deviations from it may lead to error messages\n#' that are difficult to understand; see \\dQuote{Details}.\n#' \n#' The first line is a header, and must contain the words \\code{Key},\n#' \\code{Description}, \\code{Start}, \\code{End}, \\code{Done}, and\n#' \\code{NeededBy}, written exactly in this way, with commas separating the\n#' words.  (Blanks are ignored in this line.)\n#' \n#' Additional lines indicate the details of each of several sub-projects, in\n#' comma-separated items, as follows:\n#' \n#' \\itemize{ \\item A key for the task.  These must be distinct, and are\n#' typically just the numbers 1, 2, 3, etc.\n#' \n#' \\item A description of the task.  (This may not contain commas!)\n#' \n#' \\item The start time for the task, in ISO 8601 format (\\code{YYYY-MM-DD} or\n#' \\code{YYYY-MM-DD hh:mm:ss}).\n#' \n#' \\item The end time for the task, in the same format as the starting time.\n#' \n#' \\item A number indicating the percentage of this task that has been\n#' completed to date.\n#' \n#' \\item A space-separated optional list of numbers that indicate the keys of\n#' other tasks that depend on this one.  This list is ignored in the present\n#' version of \\code{read.gantt}.  }\n#' \n#' Executing the code \\preformatted{ library(plan) data(gantt)\n#' print(summary(gantt)) } will create the following sample file, which may be\n#' read with \\code{\\link{read.gantt}}: \\preformatted{\n#' Key, Description,                 Start,        End, Done, NeededBy\n#'   1, Assemble equipment,     2008-01-01, 2008-03-28, 90\n#'   2, Test methods,           2008-02-28, 2008-03-28, 30\n#'   3, Field sampling,         2008-04-01, 2008-08-14, 0\n#'   4, Analyse field data,     2008-06-30, 2008-11-14, 0\n#'   5, Write methods chapter,  2008-08-14, 2008-11-14, 0\n#'   6, Write results chapter,  2008-10-14, 2009-01-15, 0\n#'   7, Write other chapters,   2008-12-10, 2009-02-28, 0\n#'   8, Committee reads thesis, 2009-02-28, 2009-03-14, 0\n#'   9, Revise thesis,          2009-03-15, 2009-03-30, 0\n#'  10, Thesis on display,      2009-04-01, 2009-04-15, 0\n#'  11, Defend thesis,          2009-04-16, 2009-04-17, 0\n#'  12, Finalize thesis,        2009-04-18, 2009-05-07, 0 \n#'}\n#' \n#' @param file a connection or a character string giving the name of the file\n#' to load.\n#' @param debug boolean, set to \\code{TRUE} to print debugging information.\n#' @return An object of type \\code{\"gantt\"}, which is a data frame containing\n#' \\code{\"description\"} (a character description of the task) \\code{\"start\"}\n#' (the task's start time), \\code{\"end\"} (the task's end time),\n#' \\code{\"progress\"} (a number giving the percent progress on this item, or\n#' \\code{NA} if none given), and \\code{\"needed.by\"} (a number giving the\n#' indices of other tasks that rely on this task, or \\code{NA} if none given).\n#' @author Dan Kelley\n#' @family things related to \\code{gantt} data\n#' @examples\n#' \n#' \\dontrun{\n#' library(plan)\n#' gantt <- read.gantt(\"demo/gantt.dat\")\n#' summary(gantt)\n#' plot(gantt)\n#' }\n#' \nread.gantt <- function(file, debug=FALSE)\n{\n    if (is.character(file)) {\n        file <- file(file, \"r\")\n        on.exit(close(file))\n    }\n    if (!inherits(file, \"connection\")) stop(\"argument `file' must be a character string or connection\")\n    if (!isOpen(file)) {\n        open(file, \"r\")\n        on.exit(close(file))\n    }\n    quiet <- !debug\n    tokens <- trim.whitespace(scan(file,what='char',sep=\",\",nlines=1,quiet=quiet))\n    check.tokens(tokens, c(\"Key\", \"Description\", \"Start\", \"End\", \"Done\", \"NeededBy\"))\n    key <- description <- start <- end <- done <- neededBy <- c()\n    while (TRUE) {\n        tokens <- trim.whitespace(scan(file, what=character(0), nlines=1,\n                                       blank.lines.skip=FALSE, quiet=quiet, sep=\",\"))\n        ni <- length(tokens)\n        if (ni > 1) {\n            if (ni < 3) stop(\"need at least 3 items per line\")\n            key <- c(key, as.numeric(tokens[1]))\n            description <- c(description, tokens[2])\n            start <- c(start, tokens[3])\n            end <- c(end, tokens[4])\n            done <- c(done, if (ni >= 5) as.numeric(tokens[5]) else NA)\n            neededBy <- c(neededBy, if (ni >= 6) as.numeric(tokens[6:ni]) else NA)\n        } else {\n            break\n        }\n    }\n    as.gantt(key=key,\n             description=as.character(description),\n             start=as.POSIXct(start),\n             end=as.POSIXct(end),\n             done=done,\n             neededBy=neededBy)\n}\n",
    "created" : 1463607892882.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4259755790",
    "id" : "A9F3C3C",
    "lastKnownWriteTime" : 1463608609,
    "last_content_update" : 1463608609,
    "path" : "~/src/plan/R/gantt.R",
    "project_path" : "R/gantt.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}